using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ConsoleGame.SplatSupport.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class SplatCompositionGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "ConsoleGame.SplatSupport.SplatCompositionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
        {
            var source = """
                // <auto-generated />
                #nullable enable
                namespace ConsoleGame.SplatSupport;

                [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class SplatCompositionAttribute : System.Attribute
                {
                }
                """;
            ctx.AddSource("SplatCompositionAttribute.g.cs", source);
        });

        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => IsCandidate(node),
            transform: static (ctx, ct) => GetCompositionInfo(ctx, ct))
            .Where(static info => info is not null)!;

        context.RegisterSourceOutput(candidates, static (spc, info) =>
        {
            if (info is null)
            {
                return;
            }

            Generate(spc, info);
        });
    }

    private static bool IsCandidate(SyntaxNode node)
        => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private static CompositionInfo? GetCompositionInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not ClassDeclarationSyntax classDeclaration)
        {
            return null;
        }

        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) as INamedTypeSymbol;
        if (symbol is null)
        {
            return null;
        }

        if (!HasSplatCompositionAttribute(symbol))
        {
            return null;
        }

        if (!classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
        {
            return null;
        }

        if (!symbol.IsStatic)
        {
            return null;
        }

        var info = new CompositionInfo(symbol);
        return info;
    }

    private static bool IsServiceProviderParameter(IParameterSymbol parameter)
    {
        if (parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) != "global::System.IServiceProvider")
        {
            return false;
        }

        return parameter.NullableAnnotation != NullableAnnotation.NotAnnotated;
    }

    private static bool HasSplatCompositionAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == AttributeFullName);

    private static void Generate(SourceProductionContext context, CompositionInfo info)
    {
        var source = BuildSource(info);
        context.AddSource(info.HintName, source);
    }

    private static string BuildSource(CompositionInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");

        if (!string.IsNullOrWhiteSpace(info.Namespace))
        {
            sb.Append("namespace ").Append(info.Namespace).AppendLine(";");
            sb.AppendLine();
        }

        foreach (var container in info.ContainingTypes)
        {
            sb.Append(container.AccessibilityText).Append(' ').Append("partial").Append(' ');
            if (container.IsStatic)
            {
                sb.Append("static ");
            }

            sb.Append("class ").Append(container.Name).AppendLine();
            sb.AppendLine("{");
        }

        sb.Append(info.AccessibilityText).Append(' ');
        if (info.IsStatic)
        {
            sb.Append("static ");
        }
        sb.Append("partial class ").Append(info.Name).AppendLine();
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly object __sync = new();");
        sb.AppendLine("    private static global::Splat.IMutableDependencyResolver? __resolver;");
        sb.AppendLine("    private static global::System.IServiceProvider? __services;");
        sb.AppendLine();
        sb.AppendLine("    internal static global::Splat.IMutableDependencyResolver EnsureResolver(global::System.IServiceProvider? services = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (__resolver is null)");
        sb.AppendLine("        {");
        sb.AppendLine("            lock (__sync)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (__resolver is null)");
        sb.AppendLine("                {");
        sb.AppendLine("                    __services = services;");
        sb.AppendLine("                    var resolver = new global::Splat.ModernDependencyResolver();");
        sb.AppendLine("                    Register(resolver, services);");
        sb.AppendLine("                    __resolver = resolver;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        return __resolver!;");
        sb.AppendLine("    }");
        sb.AppendLine();
    sb.AppendLine("    internal static T Resolve<T>(global::System.IServiceProvider? services = null)");
    sb.AppendLine("        => global::Splat.DependencyResolverMixins.GetService<T>((global::Splat.IReadonlyDependencyResolver)EnsureResolver(services))!;");
        sb.AppendLine();
        sb.AppendLine("    internal static T? ResolveOrDefault<T>(global::System.IServiceProvider? services = null) where T : class");
        sb.AppendLine("        => global::System.Linq.Enumerable.FirstOrDefault(global::Splat.DependencyResolverMixins.GetServices<T>((global::Splat.IReadonlyDependencyResolver)EnsureResolver(services)));");
        sb.AppendLine();
    sb.AppendLine("    internal static void Reset()");
    sb.AppendLine("    {");
    sb.AppendLine("        if (__resolver is null)");
    sb.AppendLine("        {");
    sb.AppendLine("            return;");
    sb.AppendLine("        }");
    sb.AppendLine();
    sb.AppendLine("        lock (__sync)");
    sb.AppendLine("        {");
    sb.AppendLine("            if (__resolver is null)");
    sb.AppendLine("            {");
    sb.AppendLine("                return;");
    sb.AppendLine("            }");
    sb.AppendLine();
    sb.AppendLine("            try");
    sb.AppendLine("            {");
    sb.AppendLine("                ResetInternal();");
    sb.AppendLine("            }");
    sb.AppendLine("            finally");
    sb.AppendLine("            {");
    sb.AppendLine("                if (__resolver is global::System.IDisposable disposable)");
    sb.AppendLine("                {");
    sb.AppendLine("                    try { disposable.Dispose(); } catch { }");
    sb.AppendLine("                }");
    sb.AppendLine("                __resolver = null;");
    sb.AppendLine("                __services = null;");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    static partial void ResetInternal();");
        sb.AppendLine("    static partial void Register(global::Splat.IMutableDependencyResolver resolver, global::System.IServiceProvider? services);");
        sb.AppendLine("}");

        for (var i = info.ContainingTypes.Length - 1; i >= 0; i--)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private sealed class CompositionInfo
    {
        public CompositionInfo(INamedTypeSymbol symbol)
        {
            Symbol = symbol;
            Namespace = symbol.ContainingNamespace?.IsGlobalNamespace == false ? symbol.ContainingNamespace.ToDisplayString() : string.Empty;
            AccessibilityText = GetAccessibility(symbol.DeclaredAccessibility);
            IsStatic = symbol.IsStatic;
            Name = symbol.Name;
            ContainingTypes = BuildContainingTypes(symbol);
        }

        public INamedTypeSymbol Symbol { get; }
        public string Namespace { get; }
        public string AccessibilityText { get; }
        public bool IsStatic { get; }
        public string Name { get; }
        public ImmutableArray<ContainingTypeInfo> ContainingTypes { get; }
        public string HintName => $"{Symbol.ToDisplayString().Replace('.', '_').Replace('+', '_')}.Splat.g.cs";

        private static ImmutableArray<ContainingTypeInfo> BuildContainingTypes(INamedTypeSymbol symbol)
        {
            var builder = ImmutableArray.CreateBuilder<ContainingTypeInfo>();
            var current = symbol.ContainingType;
            while (current is not null)
            {
                builder.Insert(0, new ContainingTypeInfo(GetAccessibility(current.DeclaredAccessibility), current.IsStatic, current.Name));
                current = current.ContainingType;
            }

            return builder.ToImmutable();
        }
    }

    private sealed class ContainingTypeInfo
    {
        public ContainingTypeInfo(string accessibilityText, bool isStatic, string name)
        {
            AccessibilityText = accessibilityText;
            IsStatic = isStatic;
            Name = name;
        }

        public string AccessibilityText { get; }
        public bool IsStatic { get; }
        public string Name { get; }
    }

    private static string GetAccessibility(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",
        Accessibility.Private => "private",
        Accessibility.Protected => "protected",
        Accessibility.ProtectedAndInternal => "protected internal",
        Accessibility.ProtectedOrInternal => "internal protected",
        _ => "internal"
    };
}
