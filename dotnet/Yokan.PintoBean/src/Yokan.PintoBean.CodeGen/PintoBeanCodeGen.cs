// Tier-2: Source generators and analyzers for Yokan PintoBean service platform

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Yokan.PintoBean.CodeGen;

/// <summary>
/// Incremental source generator for reverse-mode façade generation.
/// Generates partial class implementations for classes marked with [RealizeService].
/// </summary>
[Generator]
public class PintoBeanCodeGen : IIncrementalGenerator
{
    /// <summary>
    /// Gets the version of the CodeGen library.
    /// </summary>
    public static string Version => "0.1.0-dev";

    /// <summary>
    /// Initializes the incremental generator pipeline for reverse-mode façade generation.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Define the pipeline for classes with RealizeService attribute
        IncrementalValuesProvider<RealizeServiceTarget> realizeServiceTargets =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsClassWithAttributes(s),
                    transform: static (ctx, _) => GetRealizeServiceTarget(ctx))
                .Where(static m => m is not null)!;

        context.RegisterSourceOutput(realizeServiceTargets,
            static (spc, target) => GenerateFacadePartial(spc, target));
    }

    private static bool IsClassWithAttributes(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl 
            && classDecl.AttributeLists.Count > 0;
    }

    private static RealizeServiceTarget? GetRealizeServiceTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        // Get the class symbol
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        if (classSymbol == null) return null;

        // Look for RealizeService attribute
        var realizeServiceAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.Name == "RealizeServiceAttribute" 
                                 && attr.AttributeClass.ContainingNamespace?.ToDisplayString() == "Yokan.PintoBean.CodeGen");

        if (realizeServiceAttribute == null) return null;

        // Extract contract types from the attribute
        var contractTypes = new List<ITypeSymbol>();
        if (realizeServiceAttribute.ConstructorArguments.Length > 0)
        {
            var contractsArgument = realizeServiceAttribute.ConstructorArguments[0];
            if (contractsArgument.Kind == TypedConstantKind.Array)
            {
                foreach (var element in contractsArgument.Values)
                {
                    if (element.Value is ITypeSymbol typeSymbol)
                    {
                        contractTypes.Add(typeSymbol);
                    }
                }
            }
            else if (contractsArgument.Value is ITypeSymbol singleType)
            {
                contractTypes.Add(singleType);
            }
        }

        if (contractTypes.Count == 0) return null;

        return new RealizeServiceTarget(
            classSymbol.Name,
            classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty,
            contractTypes.ToImmutableArray(),
            classDecl.Modifiers.Any(SyntaxKind.PartialKeyword)
        );
    }

    private static void GenerateFacadePartial(SourceProductionContext context, RealizeServiceTarget target)
    {
        var source = GeneratePartialClass(target);
        context.AddSource($"{target.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GeneratePartialClass(RealizeServiceTarget target)
    {
        var sb = new StringBuilder();
        
        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        
        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Yokan.PintoBean.Runtime;");
        sb.AppendLine();
        
        // Namespace
        if (!string.IsNullOrEmpty(target.Namespace))
        {
            sb.AppendLine($"namespace {target.Namespace};");
            sb.AppendLine();
        }
        
        // Class declaration with interface implementations
        var interfaces = string.Join(", ", target.ContractTypes.Select(t => t.ToDisplayString()));
        sb.AppendLine($"public partial class {target.ClassName} : {interfaces}");
        sb.AppendLine("{");
        
        // Private fields
        sb.AppendLine("    private readonly IServiceRegistry _registry;");
        sb.AppendLine("    private readonly IResilienceExecutor _resilienceExecutor;");
        sb.AppendLine("    private readonly IAspectRuntime _aspectRuntime;");
        sb.AppendLine();
        
        // Constructor
        sb.AppendLine($"    public {target.ClassName}(IServiceRegistry registry, IResilienceExecutor resilienceExecutor, IAspectRuntime aspectRuntime)");
        sb.AppendLine("    {");
        sb.AppendLine("        _registry = registry ?? throw new ArgumentNullException(nameof(registry));");
        sb.AppendLine("        _resilienceExecutor = resilienceExecutor ?? throw new ArgumentNullException(nameof(resilienceExecutor));");
        sb.AppendLine("        _aspectRuntime = aspectRuntime ?? throw new ArgumentNullException(nameof(aspectRuntime));");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Generate method implementations for each contract
        foreach (var contractType in target.ContractTypes)
        {
            GenerateMethodImplementations(sb, contractType);
        }
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateMethodImplementations(StringBuilder sb, ITypeSymbol contractType)
    {
        // Get all public methods from the interface
        var methods = contractType.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary && m.DeclaredAccessibility == Accessibility.Public);

        foreach (var method in methods)
        {
            GenerateMethodImplementation(sb, contractType, method);
            sb.AppendLine();
        }
    }

    private static void GenerateMethodImplementation(StringBuilder sb, ITypeSymbol contractType, IMethodSymbol method)
    {
        var contractTypeName = contractType.ToDisplayString();
        var methodName = method.Name;
        var returnType = method.ReturnType.ToDisplayString();
        
        // Build parameter lists
        var parameters = method.Parameters.Select(p => 
            $"{p.Type.ToDisplayString()} {p.Name}").ToArray();
        var parameterList = string.Join(", ", parameters);
        
        var argumentList = string.Join(", ", method.Parameters.Select(p => p.Name));
        
        // Determine if method is async
        bool isAsync = method.ReturnType.Name == "Task" || 
                      (method.ReturnType is INamedTypeSymbol namedType && 
                       namedType.IsGenericType && namedType.ConstructedFrom.Name == "Task");
        
        // Method signature - add async keyword if needed
        var asyncModifier = isAsync ? "async " : "";
        sb.AppendLine($"    public {asyncModifier}{returnType} {methodName}({parameterList})");
        sb.AppendLine("    {");
        
        // Create parameter array for aspect runtime
        var paramNames = method.Parameters.Select(p => p.Name).ToArray();
        var paramArray = paramNames.Length > 0 
            ? $"new object?[] {{ {string.Join(", ", paramNames)} }}"
            : "new object?[0]";
        
        sb.AppendLine($"        using var context = _aspectRuntime.EnterMethod(typeof({contractTypeName}), \"{methodName}\", {paramArray});");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        
        if (isAsync)
        {
            // Async method implementation
            if (method.ReturnType.Name == "Task" && method.ReturnType is INamedTypeSymbol taskType && !taskType.IsGenericType)
            {
                // Task (no return value)
                sb.AppendLine($"            await _resilienceExecutor.ExecuteAsync(async ct => ");
                sb.AppendLine($"                await _registry.For<{contractTypeName}>().InvokeAsync(async (service, ct) => ");
                sb.AppendLine($"                    await service.{methodName}({argumentList}), ct), CancellationToken.None);");
                sb.AppendLine("            _aspectRuntime.ExitMethod(context, null);");
            }
            else
            {
                // Task<T>
                sb.AppendLine($"            var result = await _resilienceExecutor.ExecuteAsync(async ct => ");
                sb.AppendLine($"                await _registry.For<{contractTypeName}>().InvokeAsync(async (service, ct) => ");
                sb.AppendLine($"                    await service.{methodName}({argumentList}), ct), CancellationToken.None);");
                sb.AppendLine("            _aspectRuntime.ExitMethod(context, result);");
                sb.AppendLine("            return result;");
            }
        }
        else
        {
            // Sync method implementation
            if (method.ReturnType.SpecialType == SpecialType.System_Void)
            {
                // void method
                sb.AppendLine($"            _resilienceExecutor.Execute(() => ");
                sb.AppendLine($"            {{");
                sb.AppendLine($"                _registry.For<{contractTypeName}>().Invoke(service => ");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    service.{methodName}({argumentList});");
                sb.AppendLine($"                    return (object?)null;");
                sb.AppendLine($"                }});");
                sb.AppendLine($"                return (object?)null;");
                sb.AppendLine($"            }});");
                sb.AppendLine("            _aspectRuntime.ExitMethod(context, null);");
            }
            else
            {
                // method with return value
                sb.AppendLine($"            var result = _resilienceExecutor.Execute(() => ");
                sb.AppendLine($"                _registry.For<{contractTypeName}>().Invoke(service => service.{methodName}({argumentList})));");
                sb.AppendLine("            _aspectRuntime.ExitMethod(context, result);");
                sb.AppendLine("            return result;");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine("            _aspectRuntime.RecordException(context, ex);");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private class RealizeServiceTarget
    {
        public string ClassName { get; }
        public string Namespace { get; }
        public ImmutableArray<ITypeSymbol> ContractTypes { get; }
        public bool IsPartial { get; }

        public RealizeServiceTarget(string className, string @namespace, ImmutableArray<ITypeSymbol> contractTypes, bool isPartial)
        {
            ClassName = className;
            Namespace = @namespace;
            ContractTypes = contractTypes;
            IsPartial = isPartial;
        }
    }
}