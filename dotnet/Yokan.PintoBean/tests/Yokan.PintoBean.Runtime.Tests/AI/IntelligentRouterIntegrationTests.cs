// Integration tests for IntelligentRouter with ServiceRegistry

using System.Threading.Tasks;
using Xunit;
using Yokan.PintoBean.Abstractions;
using Yokan.PintoBean.Runtime;
using Yokan.PintoBean.Runtime.AI;

namespace Yokan.PintoBean.Runtime.Tests.AI;

/// <summary>
/// Integration tests showing how IntelligentRouter integrates with the actual ServiceRegistry.
/// Demonstrates end-to-end usage scenarios.
/// </summary>
public class IntelligentRouterIntegrationTests
{
    /// <summary>
    /// Simple test AI provider for integration testing.
    /// </summary>
    private class TestProvider : IAIText
    {
        public string Name { get; }
        public int CallCount { get; private set; }

        public TestProvider(string name) => Name = name;

        public Task<AITextResponse> GenerateTextAsync(AITextRequest request, System.Threading.CancellationToken cancellationToken = default)
        {
            CallCount++;
            return Task.FromResult(new AITextResponse
            {
                Content = $"Generated by {Name}: {request.Prompt}",
                ModelInfo = Name
            });
        }

        public async System.Collections.Generic.IAsyncEnumerable<AITextResponse> GenerateTextStreamAsync(AITextRequest request, [System.Runtime.CompilerServices.EnumeratorCancellation] System.Threading.CancellationToken cancellationToken = default)
        {
            CallCount++;
            yield return new AITextResponse
            {
                Content = $"Stream from {Name}: {request.Prompt}",
                ModelInfo = Name,
                IsComplete = true
            };
            await Task.Yield();
        }

        public Task<AITextResponse> ContinueConversationAsync(AITextRequest request, System.Threading.CancellationToken cancellationToken = default)
        {
            CallCount++;
            return Task.FromResult(new AITextResponse
            {
                Content = $"Conversation by {Name}: {request.Prompt}",
                ModelInfo = Name
            });
        }

        public async System.Collections.Generic.IAsyncEnumerable<AITextResponse> ContinueConversationStreamAsync(AITextRequest request, [System.Runtime.CompilerServices.EnumeratorCancellation] System.Threading.CancellationToken cancellationToken = default)
        {
            CallCount++;
            yield return new AITextResponse
            {
                Content = $"ConversationStream from {Name}: {request.Prompt}",
                ModelInfo = Name,
                IsComplete = true
            };
            await Task.Yield();
        }

        public Task<AITextResponse> CompleteTextAsync(AITextRequest request, System.Threading.CancellationToken cancellationToken = default)
        {
            CallCount++;
            return Task.FromResult(new AITextResponse
            {
                Content = $"Completed by {Name}: {request.Prompt}",
                ModelInfo = Name
            });
        }
    }

    [Fact]
    public async Task IntelligentRouter_EndToEndIntegration_CostOptimization()
    {
        // Arrange - Create real ServiceRegistry and providers
        var registry = new ServiceRegistry();
        
        var expensiveProvider = new TestProvider("ExpensiveGPT");
        var cheapProvider = new TestProvider("CheapGPT");
        var midProvider = new TestProvider("MidGPT");

        // Register providers with cost metadata
        registry.Register<IAIText>(expensiveProvider, 
            ProviderCapabilities.Create("expensive-gpt")
                .AddMetadata("costPer1KTokens", 0.50m));
                
        registry.Register<IAIText>(cheapProvider, 
            ProviderCapabilities.Create("cheap-gpt")
                .AddMetadata("costPer1KTokens", 0.10m));
                
        registry.Register<IAIText>(midProvider, 
            ProviderCapabilities.Create("mid-gpt")
                .AddMetadata("costPer1KTokens", 0.25m));

        // Create IntelligentRouter with cost optimization
        var routerOptions = RouterOptions.ForCostOptimization(0.60m);
        var router = new IntelligentRouter(registry, routerOptions);

        var request = new AITextRequest { Prompt = "Write a haiku about cost optimization" };

        // Act
        var response = await router.GenerateTextAsync(request);

        // Assert - Should select the cheapest provider
        Assert.Equal("CheapGPT", response.ModelInfo);
        Assert.Contains("CheapGPT", response.Content);
        Assert.Equal(1, cheapProvider.CallCount);
        Assert.Equal(0, expensiveProvider.CallCount);
        Assert.Equal(0, midProvider.CallCount);
    }

    [Fact]
    public async Task IntelligentRouter_EndToEndIntegration_LatencyOptimization()
    {
        // Arrange
        var registry = new ServiceRegistry();
        
        var slowProvider = new TestProvider("SlowGPT");
        var fastProvider = new TestProvider("FastGPT");

        // Register providers with latency metadata
        registry.Register<IAIText>(slowProvider, 
            ProviderCapabilities.Create("slow-gpt")
                .AddMetadata("avgLatencyMs", 1000));
                
        registry.Register<IAIText>(fastProvider, 
            ProviderCapabilities.Create("fast-gpt")
                .AddMetadata("avgLatencyMs", 200));

        // Create IntelligentRouter with latency optimization
        var routerOptions = RouterOptions.ForLowLatency(500);
        var router = new IntelligentRouter(registry, routerOptions);

        var request = new AITextRequest { Prompt = "Respond quickly" };

        // Act
        var response = await router.GenerateTextAsync(request);

        // Assert - Should select the fastest provider
        Assert.Equal("FastGPT", response.ModelInfo);
        Assert.Contains("FastGPT", response.Content);
        Assert.Equal(1, fastProvider.CallCount);
        Assert.Equal(0, slowProvider.CallCount);
    }

    [Fact]
    public async Task IntelligentRouter_EndToEndIntegration_InternalOnlyConstraint()
    {
        // Arrange
        var registry = new ServiceRegistry();
        
        var internalProvider = new TestProvider("InternalGPT");
        var externalProvider = new TestProvider("ExternalGPT");

        // Register providers with different external status
        registry.Register<IAIText>(internalProvider, 
            ProviderCapabilities.Create("internal-gpt")
                .AddTags("internal"));
                
        registry.Register<IAIText>(externalProvider, 
            ProviderCapabilities.Create("external-gpt")
                .AddTags("external"));

        // Create IntelligentRouter with internal-only policy
        var routerOptions = RouterOptions.InternalOnly();
        var router = new IntelligentRouter(registry, routerOptions);

        var request = new AITextRequest { Prompt = "Use internal providers only" };

        // Act
        var response = await router.GenerateTextAsync(request);

        // Assert - Should select only internal provider
        Assert.Equal("InternalGPT", response.ModelInfo);
        Assert.Contains("InternalGPT", response.Content);
        Assert.Equal(1, internalProvider.CallCount);
        Assert.Equal(0, externalProvider.CallCount);
    }

    [Fact]
    public async Task IntelligentRouter_CanBeRegisteredAsProvider_InServiceRegistry()
    {
        // Arrange - Demonstrate that IntelligentRouter can itself be registered as a provider
        var backendRegistry = new ServiceRegistry();
        var frontendRegistry = new ServiceRegistry();
        
        var backendProvider = new TestProvider("BackendGPT");
        
        // Register backend provider
        backendRegistry.Register<IAIText>(backendProvider, 
            ProviderCapabilities.Create("backend-gpt")
                .AddMetadata("costPer1KTokens", 0.15m));

        // Create IntelligentRouter and register it as a provider in the frontend registry
        var router = new IntelligentRouter(backendRegistry, RouterOptions.Default);
        frontendRegistry.Register<IAIText>(router, 
            ProviderCapabilities.Create("intelligent-router")
                .AddTags("router", "smart"));

        // Use the frontend registry to get the router
        var registrations = frontendRegistry.GetRegistrations<IAIText>();
        var routerRegistration = registrations.First();
        var retrievedRouter = (IAIText)routerRegistration.Provider;

        var request = new AITextRequest { Prompt = "Route this request" };

        // Act
        var response = await retrievedRouter.GenerateTextAsync(request);

        // Assert - The router should have selected and used the backend provider
        Assert.Equal("BackendGPT", response.ModelInfo);
        Assert.Contains("BackendGPT", response.Content);
        Assert.Equal(1, backendProvider.CallCount);
    }
}